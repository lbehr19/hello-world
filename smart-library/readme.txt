My Books Database by Leah Behr

About:
-background
I proposed this project because I have always loved books and reading. The original idea was 
to make something which would help me keep track of all my books, like a small library database.
Part of what might've made that interesting is that my collection is almost like an aggregate 
of my family's books; some of the books on my shelves are my mother's, others being my brother's.
Occasionally, I do lend my books to friends or family, so it would've been nice to have some way 
of keeping track of where they all are. But when you get down to brass tacks, that isn't quite as 
interesting as it could've been. As the semester progressed, we discussed scraping book information
off the web, preferably from the college library's affiliate, WorldCat. Since I could not gain 
access to that API, we went with a different, older, less-refined database: the ISFDB, short for 
the Internet Speculative Fiction Database. This one in particular lined up really well with my
reading habits, as most of what I read is science fiction or fantasy, both of which tend to fall
into the category of speculative fiction. Using the ISFDB, I was able to get information on tags 
attached to the books, rather than generating them myself, allowing me to easily create functions
to recommend a reading list for myself. 

-dependencies
Running this project does depend on the user having BeautifulSoup version 4.4.0 installed, as well as having
access to the following modules: requests, random, sqlite3, and (if planning on using the stub file) os.path

-files included
Not all of the files are necessary to run the REPL; I have included the original CSV file used to populate
the initial database, as well as an early version of the .db file that was connected to the REPL. The
conference_stub file is also included to demonstrate the code used to create the database initially,
although none of that code is actively called upon in the main repl. 

-how to use the database
Start by running the conf_repl file in your Python shell, IDE, whatever you like to use. It should
print out the menu right away, giving the user the possible choices:
1) Add/update a new/recently read book to the database.
    This option allows the user to either add an entirely new book to the database or update the 
    year_read value of a currently existing book in the database. The first option, adding a new
    book, also allows the user to specify Series information for the book as well. After adding a
    new book, the Tags table is automatically updated based on whatever information can be found
    from the ISFDB. The second option, to update the year_read, allows the user to input a more 
    recent year_read, if the user has recently re-read an old book. 
2) Get a recommendation based on tags.
    This option allows the user to specify if they would like to read something that fits into a 
    particular tag. It will then give the user 5 recommendations with the given tag, kept in the 
    Recs table. We'll get to how the Recs table was created and is maintained later. 
3) Get a recommendation based on series.
    This option allows the user to specify a certain series that they have been reading, and find 
    out whether there are more books in the series which they can continue to read. Unfortunately, 
    the Recs table does not have a way of periodically updating itself if a series is still coming
    out with new books. However, it is already populated with information from the most recently
    read series; but we'll get to the specifics of that later.
4) Get Leah's reading statistics. 
    This feature allows the user to view some reading statistics that might be of interest, including
    the top five tags in the database, the most-read authors, which series Leah has read the most from,
    and the five most recently completed books. 
5) Compare a book entry with the ISFDB. 
    I created this option as a way of getting around the issue of inconsistency between my database 
    and the ISFDB; small spelling differences, using abbreviated series names, things like that. The
    REPL option allows the user to search for a book within my database, then grab the information for
    said book from the ISFDB based on isbn. It will then display the info from both databases and ask 
    the user if they would like to adjust the info in my database to match that of the ISFDB. If the 
    database has missing tags, those are updated in the Tags table. 
6) Add a recommendation from a friend/other source.
    This was added as a way to allow the user to add their own recommendations, not generated by the ISFDB
    tags or by series. Theoretically, the host-program functions would treat these recommendations with
    more 'weight' by displaying them before other recommendations, if there was an option to view recommendations
    without having to specify the tag/series name. 
7) Give me a book to read.
    When I said 'theoretically' in the above option, I meant 'Realistically'. This is a way of grabbing a 
    recommendation without searching for it by tag or series. It displays recs one at a time until the user is 
    satisfied; the order in which recs are displayed depends on the recommendation reason (tag, series, other).
    In the future, the function might do a semi-random weighted selection, in which titles that appear in Recs 
    multiple times or user-created recommendations have a higher chance of being selected. 
q) Exit the REPL. 

Schema:
CREATE TABLE Books (
    isbn INTEGER NOT NULL,
    title CHARACTER VARYING(50),
    author CHARACTER VARYING(50),
    year_read INTEGER NOT NULL,
    genre CHARACTER VARYING(50),
    PRIMARY KEY(isbn)
)

CREATE TABLE Series (
    name CHARACTER VARYING(50) NOT NULL,
    book_isbn INTEGER NOT NULL,
    position INTEGER,
    PRIMARY KEY (name, book_isbn),
    FOREIGN KEY (book_isbn) REFERENCES Books(isbn)
)
The Series table is included because many of the books that I have enjoyed, as well as speculative fiction books
in general, are part of larger series. This table has an entry for each book as well as the name of the series
that it's in; it also keeps track of the order of the series. It is up to the user whether this refers to
chronological order or order of publication. 

CREATE TABLE Tags (
    book_isbn INTEGER NOT NULL,
    book_title CHARACTER VARYING(50) NOT NULL,
    book_author CHARACTER VARYING(50) NOT NULL,
    tag CHARACTER VARYING(50) NOT NULL,
    PRIMARY KEY (book_isbn, tag),
    FOREIGN KEY (book_isbn, book_title, book_author) REFERENCES Books(isbn, title, author)
)

CREATE TABLE Recs (
    title CHARACTER VARYING(50) NOT NULL,
    author CHARACTER VARYING(50) NOT NULL,
    tag CHARACTER VARYING(50) NOT NULL,
    id INTEGER PRIMARY KEY NOT NULL AUTOINCREMENT
)
I had attempted to make use of the convenient AUTOINCREMENT option that's available in SQLite, but for some 
reason this was throwing errors in my code, so instead my Python functions find the largest id already in Recs 
and then increases that by 1 for the new record. I'm leaving the AUTOINCREMENT clause in the SQLite schema 
just in case it does become useful in the future.

A Few Curious Queries and Their Purposes:
-"SELECT name, year_read, title, author 
  FROM Books NATURAL JOIN (SELECT name, book_isbn as isbn, position 
                          FROM Series) 
  GROUP BY year_read 
  ORDER BY year_read DESC"
While this query doesn't have any WHERE clause, it does require a join between Books and Series, which meant that 
Series had to be reworked so that book_isbn was named the same as isbn. The query is designed to help me locate 
the series information as well as title and author from the books that had been most recently read. It is used 
in the function series_recommend within the conf_repl file. 
-The generate_random_rec function in the repl file makes use of multiple queries. First it gathers a list of all 
tags used in recommendations: "SELECT tag, count(*) FROM Recs GROUP BY tag ORDER BY count(*) DESC". Then, 
after making sure that the 'other' tag is at the front of that list (for reasons discussed below), the function 
iterates through that list of popular tags. On the inside of that iteration, it creates the list of recommendations 
that include the current popular tag using "SELECT * FROM Recs WHERE tag=?", and then it iterates through each 
individual recommendation on that list until the user decides to stop. 
-I'm sure there are others, but my code is still pretty messy, so I'm not sure where they are anymore. 

A Note about the Scraping functions:
The ISFDB is rather old-fashioned in its organization; given that their supplied API is written in Python 2,
I doubt it is ever updated consistently. This happens to be a good thing, in my case, because while its current 
structure, post-BeautifulSoup parsing, is overly complicated, the fact that it will not likely be changed means
that my current methods for scraping will (hopefully) last for some time. But for some reason, as it is now, 
BeautifulSoup parses the web pages with '\n' strings in between most of the elements, so if you happen to see 
some odd indexing in my traversals through BeautifulSoup objects, it is because I am skipping over '\n' strings. 

Creation and Maintenance of the Database:
(Functions used in creating the database are located in conference_stub; functions to maintain the database
are located in either conf_scraper or conf_repl, depending on how high-level the functions are and whether
they scrape the ISFDB or not.)
-The original Books and Series tables were created by me after typing out a long CSV file of about 100 entries.
Each line of the CSV contained title, author, genre, the most recent year it was read, and isbn (obtained from
either the book itself or the internet). If applicable, it also had the series it was in and its position within
that series. I used a function, contained in the conference_stub file for anyone interested, to parse the CSV
and then insert that information into the database. (The original CSV file is also available to interested 
parties.) The Books and Series table can be maintained from the REPL, using command #1 in the main menu.
-The Tags table was created from information scraped off the ISFDB. Starting with books that were already in the
database, it searched ISFDB based on isbn number, which would locate their Publication record, which does not hold
any tags. Using the Publication record, however, the web parsers locate the link to the Title record, which does
contain tag information, as well as author, title, and series. The Tags table is now maintained automatically by
functions called within the REPL after a user enters a new book in the database or if the user decides to make
changes based on the ISFDB comparison option. 
-The Recs table was created and is currently maintained using more web scraping. Depending on the method of 
finding recommendations, either based on tag or series, different scrapers were used. 
    -If searching by tags, the scrapers locate the tag using the generic search URL, then on the tag's page, it 
    will locate books which are labeled with that tag using the HTML table on the web page. Unfortunately, since
    the table sorts the books in order of publication from most recent to least recent, most of the books in the 
    Recs table are brand new and not very well known. Additionally, since there is no way of knowing the maximum 
    number of web pages which the table may span, there is no easy way to ensure that picking a random number will
    give back a valid web page with more tags on it. However, I have created a small workaround, wherein if a page 
    number is too large and contains no tags, it will check the page that is half as big, then so on until a viable
    page is found. The amount of new recs that are inserted for a particular tag is based on the number of entries 
    in the Tags table containing that tag: more entries mean more popular tag, meaning it gets more recs. 
    -If searching by series, the scrapers locate the ISFDB's series page, if one exists for the series as it is 
    named within my database. Then, using some complicated scrapers to iterate through a badly-organized tree of
    HTML list elements, I find the books that are listed in that series and the order in which they are listed.
    New recommendations are only added to the Recs table if the book is not already in the database, and if its
    position within the series is greater than the greatest position for that series in my Series table (this 
    assumes that the user is reading the books in the order they are listed). 
The Recs table was created using the same functions (or slightly older versions of the same functions) which 
are also used to 'refresh' the entries, once the number of records in the table drops below 100 or so. Records 
are automatically removed from the table if the user inserts a book with the same title and author into the 
Books table. 

Existing Bugs (or Features):
-The way that series-based recommendations work isn't working out very well; the program does not crash, but 
    it isn't currently producing the desired results. First time trying to use menu option 3, it did not print 
    a complete list of 5 recommendations. This is likely due to a problem with how the database was first 
    populated, as a quick glance over the series listed in the Recs table shows series names that I have not 
    read in a long time. As such, it would likely be better off if, rather than search for the 3 most recently 
    read series, the user was allowed to specify a series that they'd like to go back to. Then, if information 
    on that series is not already in the Recs table, the program could attempt to scrape it from the ISFDB and 
    add it in. However, since the current process involves one of the more interesting queries, I will leave it 
    as is for the purposes of this project. 

Minor Improvements: (implemented changes)
*note to self: since the isfdb webpage also keeps track of additional tags for a book, maybe create multiple entries in Recs-one for each tag?
    -got this implemented last minute; made appropriate changes to add_tags_from_table in conf_scraper. The data in the db has not been modified and might not comply with these changes.
*note to self: make it so that the Rec refreshers might only select books by authors that are already in my database?
    -this is implemented: support now exists within the check_rec function in conf_scraper, and each higher-level function which calls this in both conf_scraper and conf_repl has been adjusted accordingly. 
                (but not in series recommendations-we assume that all series are authored by the same person, or that it doesn't matter.)
*note to self: allow ways for the user to pick new recommendations if none of the recs in the current table are interesting enough
    -got this implemented in the REPL; changes made to tag_recommend, get_recs_by_tag in conf_repl: included min_id parameter

Major Improvements: (un-implemented changes)
One idea that I had for improving and expanding the database and the REPL as to create support for different users
who could also log in to the database, include books that they have read recently, and receive their own 
recommendations. This would make it possible to create a web-based implementation for multiple users in the future,
although hopefully it would be connected to a larger and more refined database than the ISFDB.
To that end, I have devised a potential schema that could be used to re-organize the information that is already
included in the database:

CREATE TABLE Users (
    name CHARACTER VARYING(50) PRIMARY KEY NOT NULL,
    password CHARACTER VARYING(50) NOT NULL
)
CREATE TABLE History (
    user CHARACTER VARYING(50) NOT NULL,
    book_isbn INTEGER NOT NULL,
    year_read INTEGER NOT NULL,
    PRIMARY KEY (user, book_isbn),
    FOREIGN KEY (user) REFERENCES Users(name),
    FOREIGN KEY (book_isbn) REFERENCES Books(isbn)
)
CREATE TABLE Books(
    isbn INTEGER NOT NULL,
    title CHARACTER VARYING(50),
    author CHARACTER VARYING(50),
    PRIMARY KEY(isbn)
)
CREATE TABLE Recs (
    title CHARACTER VARYING(50) NOT NULL,
    author CHARACTER VARYING(50) NOT NULL,
    tag CHARACTER VARYING(50) NOT NULL,
    user CHARACTER VARYING(50) NOT NULL,
    id INTEGER NOT NULL AUTOINCREMENT,
    PRIMARY KEY (id),
    FOREIGN KEY (user) REFERENCES Users(name)
)
CREATE TABLE Tags (
    book_isbn INTEGER NOT NULL,
    tag CHARACTER VARYING(50) NOT NULL,
    PRIMARY KEY (book_isbn, tag),
    FOREIGN KEY (book_isbn) REFERENCES Books(isbn)
)
(the Series table would not be affected.)
Besides keeping track of user information, i.e. name and password, in its own table, user's reading history would
be kept in the History table; it would be organized by connecting the name of the user from the Users table with a 
book isbn from the Books table, and it would also include the most recent year that the user has read that book.
This means removing the 'year_read' field from the original Books table. I have also chosen to remove the 'genre' 
field because the current database is not affected by it, and in most cases, the genre is already one of the tags in
the Tags table. The Recs table would also be changed slightly to add in the name of the user for whom the book is 
recommended. Because of the way this is organized, it allows the database to tailor new recommendations to a 
specific user. It may also mean that the same user can be recommended the same book multiple times, but for different 
reasons each time; this is not a bad thing, as a host program could examine the number of times that one book is 
recommended to a single user to decide which recommendations are best. In the Tags table, I have taken out the title
and author fields to eliminate redundancy; since the title and author are implied by the isbn, they do not need to 
be kept in the Tags table in addition to being in the Books table. 

Because the data is split up between more tables, this would mean taking advantage of more natural joins 
and host-language functions in order to improve the efficiency of the current queries being asked. The necessary 
changes that would need to be made to the current repl to reflect the proposed schema above are as follows:
    main_repl would need to be changed to include an initial login and the option to log out
    add_to_db would have to check whether the added book is already in the books table; if not, add it, otherwise just make a new record in the History table. 
        The conditional checks involving recommendations would also be adjusted: only delete recommendations for the user currently logged in, and only refresh the recs table if a particular user's recommendation count is below minimum.
    update_db would be somewhat simplified; search Books by title to find isbn, then locate the proper record in History by isbn and user, then update year_read value.
    tag_recommend and series_recommend would be changed so that the SQL queries had an extra "WHERE user=?" with the current user's name. This change would also be applied to any of the get_recs functions.
    The add_tags function would no longer require title and author. 
    check_with_isfdb would be changed to reflect the current database's structure. 
In conf_scraper, any of the functions dealing with recommendations would need to include a parameter for the current 
username of the person logged in. 
In other words, it's far too much to be doing right now, but perhaps sometime in the far future. 